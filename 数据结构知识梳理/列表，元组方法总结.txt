一，列表和元组的特点：
列表：
1.列表是可变的
2.列表内支持索引
3.列表是有顺序的线性结构
4.列表内的元素可以是任意的合法元素，int，str，list，tuple，dict，class等都可以
元组：
1.元组的不可变的
2.元组的有序的
3.元组可支持索引
4.元组只能是只读的


二，数据的增删改查四种方法：
列表：
1.增加元素：增加元素的方法比较多，append，insert，extend，+，* 等
append(obj) 尾部追加元素   insert(index, obj) 指定的索引处增加元素 extend(iteratable) 尾部批量追加
前两种方法的区别，首先最重要的就是时间复杂度问题，append时间复杂度是O(1)，通过偏移量一步到位，效率很高。
insert因为是要在列表中间插入元素，所以说要先找到插入点，那么就要遍历，一遍历时间复杂度就是O(n)，这就不是
一步到位了，是n步到位了，很有效率问题。一些小列表的操作还可以，一旦列表上了规模遍历起来就很费事。所以在
插入元素的时候应该考虑好到底有没有中间插入的必要。

前三种方法都是就地修改的，直接在原列表上进行修改，不会返回一个新列表，insert如果超越上界就尾部追加，如果
超越下界，就头部追加。extend需要一个可迭代对象，是在尾部批量的追加元素，三种方法返回值都是None。

后两种方法 + 和 * 不是就地修改，不修改原有列表，而是返回一个新的列表。+ 就是将两个列表相加返回一个新的长
列表，这时内存中有两个老列表和一个新生成的列表，内存空间占用在原有基础上翻了一倍。这种方法比较消耗内存，
因为生成一个列表需要开辟一个连续的内存空间，而 + 方法将两个列表合成一个新的大列表，并不是前一个吞并后一
个，而是在这两个列表后面又要开辟一个新的，与前两个列表相当的连续的内存空间来存放这个新生成的列表，很耗费
资源。* 就是重复操作，将本列表内的元素重复N次。

2.删除元素：pop(obj) 直接弹出尾部最后一个元素  pop(index) 弹出指定索引处的元素  remove(value) 从左到右进行
匹配，匹配到第一个value值删掉。
删除元素有三种方法，从时间复杂度来说，第一种最快是O(1)，在尾部直接弹出不用遍历也没有效率问题。第二和第三
种时间复杂度都是O(n)，因为不管是查找索引也好还是匹配值也好，都需要一个个的遍历元素，就有了效率问题。
remove是直接就地修改了，pop方法会把弹出的元素给你返回回来。pop(index) 指定的索引不能超界，否则会报Index
Error

3.修改元素：list[index] = value 赋值即重新定义，赋值即重新修改，索引不能超界
4.查找元素：list[index] 通过索引查找元素 list.index(obj, [start, [stop]]) 通过元素查找索引值，返回匹配到的第一个值
count(value) 返回这个value的匹配次数

元组：
因为元组是不可变的，在元组被定义出来以后就无法修改了。所以元组没有增，删，改的方法。所以元组的用法不多。
查找元素：tuple[index] 通过指定索引查找对应元素。tuple.index(obj, [start, [stop]]) 通过元素查找索引值。
count(value) 返回这个value的匹配次数

三，列表的其他操作
1.reverse() 列表元素反转，就地修改
2.sort(key=None, reverse=Flase) 将列表元素进行排序，默认是升序，reverse=True时，降序排序。
sort是一个高阶函数，因为形参key如果指定那么必须是一个函数，通过指定的key进行排序。
3.in 返回的是一个bool值，某个元素在不在某个容器中，可以是列表，元组，字典等
比如：3 in [3, 4, 5] , [3, 4] in [3, 4, 5] ; 'a' in ('a', 'b', 'c') , ('a', ) in ('a', 'b', 'c') ; ('a',) in {4:'a', ('a'):99 }
列表和元组比较的是元素值，字典比较的是key，只要key在字典中，in就会返回True
4.深拷贝和浅拷贝
深拷贝和浅拷贝的区别，在列表中都是独立元素的时候，基本上没有区别。修改了一个列表另一个列表不会随着发生变化
但是一旦在列表中出现了引用类型，浅拷贝只是拷贝了一个引用而已，内存地址指向的还是一个，所以修改一个列表的引
用类型，另一个列表的引用类型会跟着发生变化。深拷贝就不会有这种问题，copy.deepcopy() 直接把内存地址也都复制
了两份，这样在进行数据修改就是各修改各的数据了，内存地址已经独立开了。
5.随机数 random模块
random.randint(a, b) 随机的返回a到b之间的一个整数
random.choice(seq) 从非空序列的元素中随机挑选一个元素，choice需要的可以是一个可迭代对象。
比如 a = [4,8,'yyyy',8,9,5,4,10,'aaa','ttt']  print(random.choice(a))
random.randrange([start,] stop [,step]) 从指定范围内，按指定基数递增的集合获取一个随机数，基数的缺省值为1
random.shuffle(list) 就地打乱列表里的元素
random.sample(population, k) 从样本空间或总体中中随机抽取k个不同的元素，组成一个新列表，这个样本空间是一个
序列或者集合类型。

四，列表与链表的区别
1.列表在连续的空间里是一个挨着一个的，是连续有序的，可以使用索引。
2.而链表在内存空间中是散落的，但他们之间会建立一种关系，相当于‘手拉手’的关系，可以从上一个找到下一个，也
可以从下一个找到上一个，链表有单向和双向的，因此链表也是有序的，但只是逻辑地址有序，在物理地址中一定是不连
续的。
列表与链表的最大区别是工作效率上的区别：
3.列表是连续的，查询会很快，只要偏移就好，但是在做中间数据的修改时会很慢，需要挪动被修改数据之后的整个队伍。
4.而链表在查询的时候没有列表这么快，它需要先一个个的找，但是在修改中间数据的效率相对于列表来说速度较快，因
为还是需要一个查找的过程，但是总的来说比列表要快一些

