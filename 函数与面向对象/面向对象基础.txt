一，什么是面向对象的思想
1.怎么理解面向对象，面向对象是相对于面向过程的另一种方法论。面向对象是将万事万物都抽象成了类，从万事万物的角度
去看这个世界，把万事万物当做第一主角。在面向对象的方法论中定义的每一个类，类里面就做类自己的事情，各个类在各个
类自己的管辖范围内处理好自己那摊子事，不要越界，基本上就能解决面向对象大部分的逻辑问题。

2.怎么理解类class和object，类是一种抽象的概念，是一类事物的共同特征的集合。比如水果，这世上有水果吗？没有，这世上
没有水果，只有苹果，香蕉，梨，但是没有水果。所以水果就是一个类，是抽象的。苹果，香蕉是object，是对象，是具体的，
是类的实例化。苹果，香蕉等是万事万物中的某些个体，而水果这个类是从具象化的水果个体上提取的一些共有特征来组成的
集合。用计算机语言来描述这个集合就是属性和方法的集合，也就是说属性和方法组成了计算机面向对象的类。

3.深层理解面向对象，面向对象有三要素：封装，继承和多态。什么是封装，对一个类进行抽象填充属性和方法就是一种封装。
什么是继承，比如人类继承自动物类，孩子继承父和母，这就是单一的继承和多继承。同样是继承自动物类的人和猫或者狗就
不一样，各有各的不同，这就是多态。

另外对于类来说，有父类就有子类，之间是有关系相连的，动物类下面可以有脊椎类，脊椎类下面还可以有哺乳类，哺乳类下
面还有人类，可以说在这个向下的过程中，类的范围逐渐的缩小，同样属性的特征也越来越细化，但是顺着这条关系线看总能
找到相同的特征，这就是继承。

继承自父类的子类，父类有什么子类就有什么，直接拿来用就行。子类也可以定义自己的属性和方法，这就是子类独有的了，父类
是不能使用的，object类是一切类的根，是根类，所有定义的类都要从object上继承。

类实例化之后的对象也是继承了类的属性和方法，因为这就是作为同一个类的共性，所以你初始化可以继承，另一个实例初始化也
是继承的这一套东西，但是实例自己可以有自己的不同于类的东西，这些独特的属性是不同于类的，从各自的字典中就能看出来

二，python中类是什么
1.类的定义
 类的定义用关键字class，标识符ClassName使用大驼峰的方式，定义完之后的类对象绑定到标识符上，在定义的class
语句块范围内开始填充类属性。
类属性包含了类变量，类方法，魔术方法也是类属性，类属性的查看可以用class.__dict__来查看，在类上定义的变量和
方法都在这个类字典上

2.类的实例化
类的实例化 __init__ 方法，这个方法里面定义的变量都是实例变量，保存在每个实例化自己的字典中
__init__方法是没有返回值的，也不能有返回值，或者说返回值必须是None
__init__是一个非常特殊的方法，调用这个方法会先实例化然后进行初始化，这个方法一定是会调用，如果自己定义的类
没有实现这个方法，python编译器也会在后面进行隐式调用
实例化第一个参数必须留给self，这个参数会在调用的时候自动传入，self只是一个形参，本质就是指的实例本身，因为
内存地址都是一样的

3.类变量和实例变量
类变量就是类范围内定义的变量，实例变量就是在__init__方法中定义的变量。
实例属性的查找顺序：
实例使用 . 号访问变量时，实例会先查找自己的__dict__, 如果自己这里没有，就通过继承关系去找类里面的__dict__, 如果自己
类里也没有，顺着继承继续往上找，找自己父类的__dict__, 最后一直找到object类上，如果都没有就报错。
但是如果实例使用__dict__[变量名] 访问变量，那么就只是找自己的字典了，有就有，没有就没有了，不会再按照继承往上找

4.实例方法，类方法和静态方法
实例方法：在类的名词空间内定义的普通函数就是类实例的方法，注意这个定义的函数一定是已经绑定self的，
调用的时候，ClassName().method() 来进行调用

类方法：用@classmethod装饰器装饰的方法，被装饰的函数必须至少有一个参数，而且第一个参数必须留给class，
使用类方法的话，就可以直接用ClassName.method() 来进行调用了。可以直接通过类来操作属性

静态方法：用@staticmethod装饰器装饰的方法，调用时，参数不会隐式的传入，也就是如果要传参需要手动传入，
所以也就不用跟self绑定在一起，可以是无参函数。静态方法只是表明这个方法属于这个名词空间而已。

在方法调用上，类可以调用类方法和静态方法，类的实例三种方法都可以调用，在调用实例方法时传入的是实例本身，
在调用类方法和静态方法时，传入的是实例的类。

三，python类属性的访问控制
私有属性：使用双下滑线开头的属性名就是私有属性，使用私有属性外部是访问不到这个属性的
通过查看__dict__可以看到私有属性的本质是在属性名前加双下划线后，python解释器会对属性进行改名，改成 _类名__变量名
保护变量：变量前加单下划线的变量，保护变量不会被改名，只是一种约定的写法
私有方法：同私有属性一样，也是会被解释器改成 _类名__方法名，单下划线的方法也是私有方法，但是不会改名。
私有成员有私有变量，保护变量，私有方法，这些加了单下划线或者双下划线被保护或者隐藏起来的方法，只是一种警告或者
提示，表示该属性不希望被修改，但是还是可以通过 _类__方法名 的方式进行访问并修改的，在python中没有什么是不能修改的

四，属性装饰器
属性装饰器是property，setter和deleter，用这三种装饰器装饰的属性必须是同名的属性。
属性装饰器的意义：把实例的属性通过私有变量保护起来，不直接暴露出去，外面只能通过getter读取属性和setter设置属性。
通过property装饰的函数名就是以后要暴露出去的属性名，这个就是getter，是必须要有的，这样类至少也是只读属性的
通过setter装饰器装饰的函数要与暴露出去的属性名同名，且接收两个参数，第一个是self，第二个是赋的值，这样属性可写。
通过deleter装饰器装饰的属性可以删除，但是很少用，一般属性不合适也就是修改了，删除的话一开始就不要设这个属性了。

这三个装饰器，property装饰器必须在第一位，后面的是setter和deleter，可有可无。不过一般实现setter

