一，单继承
1.单继承的定义
继承的定义 class 子类名(基类1[, 基类2，....])
基类就是父类，括号内写的是继承的列表，一个基类就是单继承
继承可以让子类从父类上获取属性和方法，子类共享父类的属性和方法
如果没有基类列表的表示是继承的根类object
根据OCP原则(开闭原则)，应该是多用继承，少修改，那么继承的意义就是在子类上实现对基类的增强，实现多态

2.单继承的访问控制
在查找属性的时候，类先找自己实例的__dict__，然后在找类的__dict__, 然后在找继承父类的__dict__
在继承的时候，公有属性和方法，子类和实例是都可以进行访问的，但是对于私有的变量，如果说子类上空空荡荡，那么
子类可以通过父类暴露出来的访问接口来访问父类的私有变量的，一旦子类上也有了一个跟父类同名的私有变量，那么子类
就无法跨类进行访问了，这时候各自类的私有变量只能在类范围内访问，除非通过改名的方式进行访问，但是还是慎用。

3.单继承的初始化
继承的初始化，一旦子类自己有了初始化方法，子类实例化的时候就不会去自动调父类的实例化方法，而是调用自身实例化，
这样就看不出继承的效果，这时候只能通过super()方法显式的调用父类的__init__

二，多继承

1.多继承的弊端
多继承的弊端会带来二义性，继承的类太多，继承路线冲突，很难说清什么样的继承路线，而python又太灵活，是解释执行的，
只有执行到的时候才会报错，给编译器设计增加复杂度，很多的语言因为这个原因直接就放弃了多继承，java就放弃了多继承，
python和c++目前还是支持多继承。

2.python多继承的实现
既然实现了多继承，就要解决多继承的问题，最主要的就是解决二义性，可以采用深度优先或者广度优先的策略
python实现多继承是采用了MRO(方法解析顺序)来解决基类搜索顺序问题
MRO有三种搜索算法：
在python2.2版本之前采用的是经典算法
在python2.2版本采用了新式类算法
在python2.3之后采用了C3算法，目前python3只支持C3算法了，C3算法是在类被创建出来的时候，就已经计算出了MRO
的有序列表，C3算法解决了多继承的二义性
虽然python解决了多继承的问题，但是还是要尽量的避免多继承

3.Mixin类解决多继承
python中为解决多继承问题也专门的设计了一种类，叫Mixin类，这个类的作用就是跟装饰器效果一样，起到辅助效果，实现
一种增强的目的，这个Mixin类体现了一种组合的设计模式，多组合，少继承。

Mixin类的使用原则：
Mixin类中不应该显式的出现__init__初始化方法
Mixin类不能独立的工作，这个类的作用就是为了混入其他类中实现部分功能增强的，所以最好Mixin类功能单一，如果多个
功能就写多个Mixin类(Mixin类可以在一个类中实现多功能)
Mixin类的祖先类也是Mixin类
Mixin类在使用的时候通常在继承列表的第一位置

Mixin类的作用和装饰器很像，区别在于这是一个类，是可以继承的，有了Mixin类就可以把很多的类通过一种组合的思想组合
起来，至于是选择装饰器还是选择Mixin类，对于需要继承的话选Mixin类好点

三，类的特殊属性
python中类有一些特殊的属性，比如
__name__  返回对象名，只有类有，实例没有
__module__ 返回类定义所在的模块名
 __class__ 返回对象的类型，类和实例都有，类的类型是type，实例的类型是class
__dict__ 返回对象属性的字典，类和实例都有，各有各的字典，通过字典可以知道都有哪些属性
__qualname__ 返回类的限定名，只有类有
__base__ 类的基类
__bases__ 类的基类元组，顺序就是在基类列表中出现的顺序
__doc__ 类，函数的文档字符串，如果没有定义则为None
__mro__ 显示方法查找顺序，基类的元组
mro() 这是一个方法，显示方法查找的顺序，返回的是基类的列表
__subclasses__() 这也是一个方法，返回类的子类列表

